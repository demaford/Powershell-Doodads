<#
.SYNOPSIS
    Reads the log file from the Town of Host: Enhanced mod.
.DESCRIPTION
    This script is designed to be able to score among us tournaments by reading the log files generated by the Town of Host: Enhanced mod.
    It processes the log file to extract player actions, scores them based on predefined criteria, and outputs the results in a variety of formats.
    Complete output in JSON format is the default output, but player scores or player events can be output to CSV files as well for quick scoring for events.

    Formats:
    - JSON: Complete game data including player scores, events, timestamps, and winning team.
    - CSV (Player Scores): A simple list of player names and their final scores for each game.
        Where the first column is the player name and the second column is the player's final score.
    - CSV (Player Events): A detailed list of player events including score changes for each game.
        Where the first column is the player name, the second column is the reason for the score change, and the third column is the amount of the score change.
.PARAMETER LogFilePath
    Path to the log file generated by the Town of Host: Enhanced mod to be analyzed by the script.
    Relative paths are supported.
.PARAMETER OutputFolderPath
    Path to the folder where output files will be saved.
    An output file will be created for each game found and completed in the log file.
    Relative paths are supported.
.PARAMETER PlayerScores
    Switch to output player scores to CSV files.
    The first column is the player name and the second column is the player's final score.
    An output file will be created for each game found and completed in the log file.
.PARAMETER PlayerEvents
    Switch to output player events to CSV files.
    The first column is the player name, the second column is the reason for the score change, and the third column is the amount of the score change.
    An output file will be created for each game found and completed in the log file.
.INPUTS
    System.String
    Switch
.OUTPUTS
    System.Collections.Hashtable[]
.LINK
    https://github.com/elliot-huffman/Powershell-Doodads
.EXAMPLE
    Get-AmongUsScore.ps1 -LogFilePath "C:\Program Files (x86)\Steam\steamapps\common\Among Us - ToH\BepInEx\LogOutput.log" -OutputFolderPath "C:\Tourney\"

    Analyzes the specified log file and outputs complete game data in JSON format to files in the specified output folder.
.EXAMPLE
    Get-AmongUsScore.ps1 -LogFilePath "C:\Program Files (x86)\Steam\steamapps\common\Among Us - ToH\BepInEx\LogOutput.log" -OutputFolderPath "C:\Tourney\" -PlayerScores

    Analyzes the specified log file and outputs player scores to CSV files in the specified output folder.
.EXAMPLE
    Get-AmongUsScore.ps1 -LogFilePath "C:\Program Files (x86)\Steam\steamapps\common\Among Us - ToH\BepInEx\LogOutput.log" -OutputFolderPath "C:\Tourney\" -PlayerEvents

    Analyzes the specified log file and outputs player events to CSV files in the specified output folder.
#>

# Define the system requirements
#Requires -Version 7
#Requires -PSEdition Core
#Requires -Modules Microsoft.PowerShell.Management
#Requires -Modules Microsoft.PowerShell.Utility

# Enable deep powershell integration
[CmdletBinding()]

# Initialize the parameters for the script
param (
    [Parameter(Mandatory = $true)]
    [ValidateScript({ Test-Path -Path $_ -PathType 'Leaf' })]
    [System.String]$LogFilePath,
    [Parameter(ParameterSetName = 'Output Everything')]
    [Parameter(
        Mandatory = $true,
        ParameterSetName = 'Output Mode - Player Scores'
    )]
    [Parameter(
        Mandatory = $true,
        ParameterSetName = 'Output Mode - Player Events'
    )]
    [ValidateScript({ Test-Path -Path $_ -PathType 'Container' })]
    [System.String]$OutputFolderPath = './',
    [Parameter(
        Mandatory = $true,
        ParameterSetName = 'Output Mode - Player Scores'
    )]
    [Switch]$PlayerScores,
    [Parameter(
        Mandatory = $true,
        ParameterSetName = 'Output Mode - Player Events'
    )]
    [Switch]$PlayerEvents
)

# Process this before the collection of log files are processed
begin {
    # Enforce strict mode for better scripting practices
    Set-StrictMode -Version 3.0

    # Regular expression used to match blocks in the log file
    [System.String]$BlockMatcher = '\[(?<block>[^\]]+)\]'

    # List of roles that are considered crewmates for player team association
    [System.String[]]$CrewRoleList = @('NoisemakerTOHE', 'EngineerTOHE', 'DetectiveTOHE', 'TrackerTOHE', 'ScientistTOHE', 'CrewmateTOHE')

    # Placeholder list of roles that are considered neutral for player team association 
    [System.String[]]$NeutralRoleList = @()

    # List of roles that are considered impostors for player team association
    [System.String[]]$ImpostorRoleList = @('PhantomTOHE', 'ShapeshifterTOHE', 'ViperTOHE', 'ImpostorTOHE')


    # List of games found in the log file, each has table contained within is a collection of player points where the key is the ID and the value is the score
    [System.Collections.Hashtable[]]$GameList = @()

    function Find-PlayerByName {
        param (
            [System.Collections.Hashtable]$CurrentGame,
            [System.String]$PlayerName
        )

        # Iterate through each player in the table and return the ID if the name matches
        foreach ($playerId in $CurrentGame.Players.Keys) {
            # Check if the player name matches
            if ($CurrentGame.Players[$playerId][0] -eq $PlayerName) {
                # Return the player ID
                return $playerId
            }
        }

        # If no player was found, return null
        return $null
    }
}

# Run this block for each log file passed in
process {
    # Read the contents of the log file
    [System.String[]]$logContents = Get-Content -Path $LogFilePath

    # Current game being processed.
    # 
    # Players: Hashtable where the key is the player ID and the value is an array of [PlayerName, Score, Team, isDead]. Team can be $null (not assigned), 'Crewmate' or 'Impostor'.
    # EventList: (array of arrays) List of events that occurred during the game, where [PlayerID, ScoreChangeReason, ScoreChangeAmount] is each entry
    # TimeStampStart: String representing the start time of the game. The timezone is from the host.
    # TimeStampEnd: String representing the end time of the game. The timezone is from the host.
    # WinnerTeam: String representing the winning team (crewmates or impostors)
    # WinsReason: String representing the reason for the win (e.g., all impostors eliminated, tasks completed, etc.)
    [System.Collections.Hashtable]$CurrentGame = @{
        'Players'             = @{}
        'EventList'           = @()
        'ShapeshiftReference' = @{}
        'TimeStampStart'      = ''
        'TimeStampEnd'        = ''
        'WinnerTeam'          = ''
        'WinsReason'          = ''
    }

    # Loop through each line in the log file and process it
    foreach ($logEntry in $logContents) {
        # Process each line to extract relevant information
        [System.Text.RegularExpressions.MatchCollection]$HeaderList = [System.Text.RegularExpressions.Regex]::Matches($logEntry, $BlockMatcher)

        # Skip the current line if no headers were found
        if ($HeaderList.Count -eq 0) { continue }

        # Value that comes after the headers in the log entry
        [System.String]$EventData = $logEntry.Substring($HeaderList[($HeaderList.Count - 1)].Index + $HeaderList[($HeaderList.Count - 1)].Length).Trim()

        # Loop through each matched log header and determine which control to trigger
        foreach ($matchValue in $HeaderList) {
            # 'OnGameJoined' - Created lobby, create a new game entry
            # 'Name player' - Player joined lobby, includes player ID and name
            # 'Phase' - Game phase change, e.g., start, meeting, end, etc.
            # 'RoleAssign' - Player's role assigned, crew, impostor, neutral, etc.
            switch ($matchValue.Groups['block'].Value) {
                # Lobby creation
                'OnGameJoined' { 
                    # Clear the current game and reset
                    $CurrentGame = @{
                        'Players'             = @{}
                        'EventList'           = @()
                        'ShapeshiftReference' = @{}
                        'TimeStampStart'      = ''
                        'TimeStampEnd'        = ''
                        'WinnerTeam'          = ''
                        'WinsReason'          = ''
                    }

                    # Stop execution to prevent fallthrough
                    break
                }
                # Player joined lobby
                'Name player' {
                    # Extract player ID from the log entry
                    [System.String]$Id = (($EventData -split '-')[0] -split ':')[1].Trim()

                    # Extract player name from the log entry
                    [System.String]$Name = ((($EventData -split '-')[1] -split '=>')[0] -split ':')[1].Trim()

                    # Initialize the detected player in the current game with 25 score, no team and alive
                    $CurrentGame.Players[$Id] = @($Name, 25, $null, $false) # [PlayerName, Score, Team, isDead]

                    # Stop execution to prevent fallthrough
                    break
                }
                # Game changes from one phase to another, e.g., start, discussion, end, etc.
                'Phase' {
                    # If the game started, extract the timestamp for the game
                    if ($EventData -eq '-----------Start of game-----------') {
                        # Extract the timestamp from the log entry and save it to the current game
                        $CurrentGame.TimeStampStart = ($HeaderList[1].Groups['block'].Value).Trim()
                    } elseif ($EventData -eq '-----------Game over-----------') {
                        # If the game ended, extract the timestamp for the game
                        # Extract the timestamp from the log entry and save it to the current game
                        $CurrentGame.TimeStampEnd = ($HeaderList[1].Groups['block'].Value).Trim()
                    }

                    # Stop execution to prevent fallthrough
                    break
                }
                'RoleAssign' {
                    # Extract role name from the event data that was assigned to the player
                    [System.String]$RoleName = ($EventData -split '=>')[1].Trim()

                    # Flag that indicates if the assigned role is an impostor role
                    [System.Boolean]$IsImpostor = $false

                    # Check if the assigned role is an impostor role and set the flag accordingly
                    if ($ImpostorRoleList -contains $RoleName) { $IsImpostor = $true }

                    # Extract player name from the event data
                    [System.String]$PlayerName = (($EventData -split '=>')[0] -split 'ï¼š')[1].Trim()

                    # ID of the player that was assigned the role
                    [System.String]$PlayerId = Find-PlayerByName -CurrentGame $CurrentGame -PlayerName $PlayerName

                    # Assign the team based on the role assigned
                    if ($IsImpostor) {
                        # Assign player as impostor
                        $CurrentGame.Players[$PlayerId][2] = 'Impostor'
                    } else {
                        # Assign player as crewmate
                        $CurrentGame.Players[$PlayerId][2] = 'Crewmate'
                    }

                    # Stop execution to prevent fallthrough
                    break
                }
                # Player completed a task
                'CompleteTask.Prefix' {
                    # Extract player name from the event data
                    [System.String]$PlayerName = (($EventData -split '-')[0] -split ':')[1].Trim()

                    # Find the player ID based on the player name
                    [System.String]$PlayerId = Find-PlayerByName -CurrentGame $CurrentGame -PlayerName $PlayerName

                    # Check if the player is alive or a ghost and assign the correct points
                    if ($CurrentGame.Players[$PlayerId][3] -eq $false) {
                        # Record the event in the event list for the player's score change
                        $CurrentGame.EventList += , @($PlayerId, 'Completed Task - Alive', 10)

                        # Add points to the crewmate player
                        $CurrentGame.Players[$PlayerId][1] += 10
                    } else {
                        # Record the event in the event list for the player's score change
                        $CurrentGame.EventList += , @($PlayerId, 'Completed Task - Ghost', 5)

                        # Add points to the crewmate player
                        $CurrentGame.Players[$PlayerId][1] += 5
                    }

                    # Stop execution to prevent fallthrough
                    break
                }
                # Player voting results
                'Vote' {
                    # Check if the vote event is the decision results
                    if ($EventData.StartsWith('Decision to exiled a player')) {
                        # Extracted voting results where [tieFlag, player Voted out ID, display name]
                        [System.String[]]$VotingResults = ($EventData.Substring(34) -split ',').Trim() -split ' '

                        # PlayerID value meanings:
                        # 255 = not voted (virtual player ID)
                        # 253 = skipped (virtual player ID)
                        # All other numbers are actual player IDs
                        # Only operate if there was no tie and a player was voted out
                        if ($VotingResults[0] -eq 'False' -and $VotingResults[1] -ne '255' -and $VotingResults[1] -ne '253') {
                            # If the player voted out was impostor, assign crew points
                            if ($CurrentGame.Players[$VotingResults[1]][2] -eq 'Impostor') {
                                # Iterate through each player in the game and find crewmates to assign points
                                foreach ($playerId in $CurrentGame.Players.Keys) {
                                    # If a crewmate is found, assign points for the action
                                    if ($CurrentGame.Players[$playerId][2] -eq 'Crewmate') {
                                        # Record the event in the event list for the player's score change
                                        $CurrentGame.EventList += , @($playerId, 'Voted Out Impostor', 50)

                                        # Add points to the crewmate player
                                        $CurrentGame.Players[$playerId][1] += 50
                                    }
                                }
                            } elseif (($CurrentGame.Players[$VotingResults[1]][2] -eq 'Crewmate')) {
                                # Otherwise, assign impostor points and subtract crew points
                                # Iterate through each player in the game and find crewmates to assign points
                                foreach ($playerId in $CurrentGame.Players.Keys) {
                                    # If a crewmate is found, assign points for the action
                                    if ($CurrentGame.Players[$playerId][2] -eq 'Crewmate') {
                                        # Record the event in the event list for the player's score change
                                        $CurrentGame.EventList += , @($playerId, 'Voted Out Crewmate - Mistake', -30)

                                        # Remove points from the crewmate player
                                        $CurrentGame.Players[$playerId][1] -= 30

                                        # Give consolation points to the voted out crew mate for their trouble
                                        if ($VotingResults[1] -eq $playerId) {
                                            # Record the event in the event list for the player's score change
                                            $CurrentGame.EventList += , @($playerId, 'Wrongfully Ejected Consolation', 15)

                                            # Remove points from the crewmate player
                                            $CurrentGame.Players[$playerId][1] += 15
                                        }
                                    } elseif ($CurrentGame.Players[$playerId][2] -eq 'Impostor') {
                                        # Record the event in the event list for the player's score change
                                        $CurrentGame.EventList += , @($playerId, 'Voted Out Crewmate - Imposter', 40)

                                        # Add points to the crewmate player
                                        $CurrentGame.Players[$playerId][1] += 40
                                    }
                                }
                            }
                        }
                    }

                    # Stop execution to prevent fallthrough
                    break
                }
                # Shapeshift action
                # TODO: Verify that shapeshift actions are being tracked correctly if more than impostor is present as the ID is not provided during a single kill log
                'ShapeshiftPatch' {
                    # Update shapeshift reference table based on current shapeshift actions

                    # Skip this event if it is a cancellation (after meeting cancellation of shapeshift)
                    if ($EventData.EndsWith(': Cancel Shapeshift.Prefix')) { break }

                    # Person before and after shapeshift [beforeName, afterName]
                    [System.String[]]$BeforeAfter = ($EventData -split '=>').Trim()

                    # Check if the shapeshift is a revert or a new shapeshift
                    if ($BeforeAfter[0] -eq $BeforeAfter[1]) {
                        # If they changed back into their original form, remove the entry from the shapeshift reference table
                        $CurrentGame.ShapeshiftReference.Remove($BeforeAfter[0])
                    } else {
                        # If they changed into a new form, add/update the entry in the shapeshift reference table
                        $CurrentGame.ShapeshiftReference[$BeforeAfter[1]] = $BeforeAfter[0]
                    }

                    # Stop execution to prevent fallthrough
                    break
                }
                # Finalization of a killing action
                # TODO: Verify that shapeshift actions are being tracked correctly if more than impostor is present as the ID is not provided during a single kill log
                'MurderPlayer Prefix' {
                    # Finalize murder action

                    # Check if the murder was successful
                    if (($EventData -split ':')[1].Trim() -eq 'Succeeded') {
                        # Do the manipulations

                        # Player (may be shapeshifted) that killed
                        [System.String]$KillingPlayer = ($EventData -split '=>')[0].Trim()

                        # Translate the killing player if shape shifted
                        if ($CurrentGame.ShapeshiftReference.ContainsKey($KillingPlayer)) {
                            # Pull the value of the original player instead of the disguised player
                            $KillingPlayer = $CurrentGame.ShapeshiftReference[$KillingPlayer]
                        }

                        # Player that was killed
                        [System.String]$DeadPlayer = (($EventData -split '=>')[1] -split ',')[0].Trim()

                        # ID of the dead player as identified by their name
                        [System.String]$DeadPlayerId = Find-PlayerByName -CurrentGame $CurrentGame -PlayerName $DeadPlayer

                        # Mark the player as dead
                        $CurrentGame.Players[$DeadPlayerId][3] = $true

                        # ID of the player that killed
                        [System.String]$KillingPlayerId = Find-PlayerByName -CurrentGame $CurrentGame -PlayerName $KillingPlayer

                        # Record the event in the event list for the player's score change
                        $CurrentGame.EventList += , @($KillingPlayerId, 'Killed Player', 25)

                        # Add points to the crewmate player
                        $CurrentGame.Players[$KillingPlayerId][1] += 25
                    }

                    # Stop execution to prevent fallthrough
                    break
                }
                # End of game: winning team
                'Winner Team' {
                    # Store the winning team in the current game
                    $CurrentGame.WinnerTeam = $EventData.Trim()

                    # Stop execution to prevent fallthrough
                    break
                }
                # End of game: winning details
                # TODO: Support sabotage win reason parsing
                'Wins Reason' {
                    $CurrentGame.WinsReason = $EventData.Trim()

                    # Stop execution to prevent fallthrough
                    break
                }
                # End of game: winning points and current game archive + reset
                'Role Summary' { 
                    # Calculate winning points
                    foreach ($playerId in $CurrentGame.Players.Keys) {
                        # If the current player is on the winning impostor team, assign impostor win points
                        if ($CurrentGame.WinnerTeam -eq 'Impostor' -and $CurrentGame.Players[$playerId][2] -eq 'Impostor') {
                            # Record the event in the event list for the player's score change
                            $CurrentGame.EventList += , @($playerId, 'Win Game - Impostor', 200)

                            # Add points to the impostor player
                            $CurrentGame.Players[$playerId][1] += 200
                        } elseif ($CurrentGame.WinnerTeam -eq 'Crewmate' -and $CurrentGame.Players[$playerId][2] -eq 'Crewmate') {
                            # Record the event in the event list for the player's score change
                            $CurrentGame.EventList += , @($playerId, 'Win Game - Crewmate', 50)

                            # Add points to the impostor player
                            $CurrentGame.Players[$playerId][1] += 50
                            
                            # Check if the current player is a crewmate and assign crewmate win points
                            if ($CurrentGame.Players[$playerId][3] -eq $false) {
                                # Record the event in the event list for the player's score change
                                $CurrentGame.EventList += , @($playerId, 'Win Game - Crewmate - Alive', 50)

                                # Add points to the impostor player
                                $CurrentGame.Players[$playerId][1] += 50
                            }
                        }
                    }

                    # Save current game and extract final stats for players
                    $GameList += $CurrentGame

                    # Reset the current game for the next one if one is found in the log file
                    $CurrentGame = @{
                        'Players'             = @{}
                        'EventList'           = @()
                        'ShapeshiftReference' = @{}
                        'TimeStampStart'      = ''
                        'TimeStampEnd'        = ''
                        'WinnerTeam'          = ''
                        'WinsReason'          = ''
                    }

                    # Stop execution to prevent fallthrough
                    break
                }
                default {
                    # Do nothing for other log entries we don't care about
                }
            }
        }
    }
}

# Process this after all log files have been processed
end {
    # Counter for the number of games processed
    [System.Int128]$GameCounter = 0

    # Foreach game computed, output the results based on the requested output mode
    foreach ($computedGame in $GameList) {
        # Increment the game counter to prevent overwriting output files
        $GameCounter = $GameCounter + 1

        # Path to output file for the current game
        [System.String]$OutputFilePath = Join-Path -Path $OutputFolderPath -ChildPath "AmongUsGame_$($GameCounter).csv"

        # Determine output mode based on parameter set
        if ($PlayerScores) {
            # Output player scores to CSV
            $GameList.players.Values | ForEach-Object -Process { (@{$_[0] = $_[1] }).GetEnumerator() } | Select-Object -Property 'Name', 'Value' | Export-Csv -Path $OutputFilePath
        } elseif ($PlayerEvents) {
            # Output player events to CSV and replace the player ID with the player name
            $GameList.eventlist | ForEach-Object -Process {
                [pscustomobject]@{
                    'playerName'        = $GameList[0].Players[$_[0]][0]
                    'scoreChangeReason' = $_[1]
                    'scoreChangeAmount' = $_[2]
                }
            } | Export-Csv -Path $OutputFilePath
        } elseif ($OutputFilePath) {
            # Write the game results to the requested file
            $GameList | ConvertTo-Json | Out-File -FilePath $OutputFilePath
        }
    }

    # Output the game results to the console host
    Write-Output -InputObject $GameList
}